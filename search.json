[
  {
    "objectID": "shinyapps.html#learning-objectives",
    "href": "shinyapps.html#learning-objectives",
    "title": "11  Shiny apps",
    "section": "11.1 Learning objectives",
    "text": "11.1 Learning objectives\nThis chapter introduces you to ShinyApps using R code to create and publish data, research materials, or informative tutorials. Chapter 11 is divided into two parts, 11a and 11b. In chapter 11a, you will learn:\n\nwhat a ShinyApp is and how to find resources,\nhow to use RStudio and shinyapps.io to publish your application and,\nhow to recognize the main components of a Shiny application.\n\nChapter 11b will take a deeper look at many of the commonly used functions for input and output so that you can begin to customize and build your own applications."
  },
  {
    "objectID": "shinyapps.html#what-is-shiny",
    "href": "shinyapps.html#what-is-shiny",
    "title": "11  Shiny apps",
    "section": "11.2 What is Shiny?",
    "text": "11.2 What is Shiny?\nShiny is an R package that builds interactive web applications using R and RStudio to compile HTML files. The HTML files can be used locally, (just opened up using your browser from a local directory), or placed on a server to make public for anyone to use. Its not just for data, either! They are used as an education tool, a map for finding resources, business intelligence (BI) dashboards, tracking activities, calculators, file type conversion, and of course, for displaying the results of data analysis through interactive visualizations.\nYou are not restricted to just the web browser. You can configure your shiny app to export other document types, like PDFs, Word, or Excel.\nThe most important aspects of Shiny are that it is interactive and it is responsive. Interactivity provides an opportunity for your viewers to engage with your materials, rather than just read it. Responsive applications resize automatically to adjust to the device being used. This means you design once, and it can be viewed on a laptop, desktop, tablet, or phone.\nIn Shiny, we code in R. In the following sections, code will be shown in cells:\n\n# this is written in R\nprint(\"Hello lovely people!\")\n\n[1] \"Hello lovely people!\""
  },
  {
    "objectID": "shinyapps.html#what-can-it-do",
    "href": "shinyapps.html#what-can-it-do",
    "title": "11  Shiny apps",
    "section": "11.3 What can it do?",
    "text": "11.3 What can it do?\nThe Shiny Gallery is really helpful when learning as the examples provided include their code, so you can see how they created the interfaces. Below, is an example of where we’re heading with this chapter and where we’ll be going in the next chapter which will lead you through the steps to creating a dashboard.\n\n\n\nAn example of a simple application from this chapter.\n\n\n\n11.3.1 Examples of dashboards and data visualization websites\nA dashboard is one that uses data that has been placed on the server, (or you have uploaded) or streams real-time and shows a variety of graphs, charts, and tables. In our examples case, we’ll use standard datasets from R as well as some from the fivethirtyeight GitHub repository. You can see the all the R data sets by typing the following in the console:\ndata()\nThe term ‘dashboard’ does apply to specific libraries made for Shiny that use a template HTML file. We are calling any website for the purpose of showing, exploring, or manipulating data with multiple visualization methods - a dashboard. So, we use it rather casually, rather than specifying specific libraries."
  },
  {
    "objectID": "shinyapps.html#how-does-it-integrate-with-other-things",
    "href": "shinyapps.html#how-does-it-integrate-with-other-things",
    "title": "11  Shiny apps",
    "section": "11.4 How does it integrate with other things?",
    "text": "11.4 How does it integrate with other things?\n\n\n\n\n\n\n11.4.1 RStudio\nThis is the IDE, the integrated development environment, for R, (among many other programming languages). We’ll be using RStudio to create our shiny apps, test the code, preview results, and manage files.\n\n\n11.4.2 Shiny\nShiny apps are built on Bootstrap which is an open-source, template HTML file with CSS and Javascript that makes it adapt to different browsers and devices. The Shiny app code does all the work to place the elements you design into an HTMLL files and automatically manages all file dependencies. We’ll briefly discuss files when getting started with your first app.\n\n\n11.4.3 shinyapps.io\nWhen running a shiny application from RStudio, you can publish directly to a server. Thankfully, the R community has a server location where you can host up to 5 apps for free at shinyapps.io. Of course, you can pay for more space, but for now, this works for us! Later on, we’ll walk you through publishing to the server directly from RStudio. Its surprisingly easy!"
  },
  {
    "objectID": "shinyapps.html#how-do-i-get-started",
    "href": "shinyapps.html#how-do-i-get-started",
    "title": "11  Shiny apps",
    "section": "11.5 How do I get started?",
    "text": "11.5 How do I get started?\nThis link to the tutorials at shiny.rstudio.com can also guide you through steps to creating your own apps, including more detailed information on how to change elements to meet your needs.\nInstall the package down below in the console. You only need to do this once. If you uninstall and re-install your RStudio, you may need to reinstall packages.\ninstall.packages(\"shiny\")\n\n11.5.1 Starting a new app\nfrom Files>New File > Shiny Web app OR select new file from the pull down menu in the top toolbar.\n\n\n\nStarting up a new Shiny app.\n\n\nThis brings up a dialog box. Enter your project name. This will become the name of the folder that is created in the location you select.\n\n\n\nSelecting your new directory location.\n\n\nOnce you select Create you will see the template shiny app. This has three sections which we will cover next.\n\n\n\nThe starting template for a Shiny app.\n\n\n\n\n11.5.2 Basic anatomy of a shiny app\nThere are three parts of a shiny app: the ui, the server, and the shinyApp() function that calls the ui and server.\nThe ui (the user interface object) specifies the layout: where items are placed on the webpage.\nThe server function is the instructions for how shiny builds your app.\nThe shinyApp() function creates the actual app from the ui and server components\n\n\n\n\n\n\nWarning\n\n\n\n\nPast versions of shiny used multi-page layouts with the ui and server components saved as separate files, such as ui.R and server.R. While this is still supported, the rest of this chapter will assume that we’re using the single-page version in which the ui and server are together in one app.R file.\n\n\n\nThe UI and the server both have inputs and outputs that will be assigned and called. We’ll go over those in the Inputs & Widgets section later on.\n\n\n11.5.3 Set up a working directory\n\nFirst set up a new working directory. In RStudio you can do this in the Files tab (usually on right lower panel). You can navigate where you want a directory, create, or modify existing directories.\n\nUnder More, select Set as working directory. You can also do this in the console with:\nsetwd(\"~/your_folder_name\")\n\nDownload the following file from github and Save Page As... from your browser to this directory. Then rename the file from FirstAppDemo.txt to FirstAppDemo.R\nLet’s open up a shiny app file, called FirstAppDemo.R. You can see there is the ui, the server, and the shinyApp() function.\n\n\n\n\nFigure 1: Image of a basic shiny app components\n\n\nWe’ll be going through each of these items in more detail, but for now, you can see the basic structure.\nTo run the app, use the Run icon shown below. This will run in the RStudio viewer by default, but you can also run in your browser with the Run external option checked.\n\n\n\nFigure 2: Image of the run icon. Note the pull down menu arrow on the right.\n\n\nThat’s it to run a basic Shiny app!!! The shiny library comes with many examples you can explore as well as even more sophisticated examples on the Gallery page.\n\n\n\nFigure 3: Examples of shiny apps and functions. Image source: https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/\n\n\nThat’s it! you’ve created a new app. Its simple right now, but we’ll explore more options later for designing something that works for your needs. Let’s discuss how we publish next so that you get a sense of the entire workflow.\n\n\n11.5.4 Publishing on shinyapps.io\nNow we can start publishing online for the world to experience your brilliant research! A free account at shinyapps.io provides space for 5 applications and 25 active hours of server time. (what are active hours?)\n\nCreate a shinyapps.io account. You will need your login info to set up your RStudio to publish directly to shinyapps.io. Click here to set up a shinyapps.io account. I recommend connecting via your GitHub account, if you have one. Otherwise, just start a new account.\nBack in RStudio, we need to connect to your shinyapp.io account. To the right of the Run icon, select the pull down menu.\n\nSelect Connect… and then choose shinyapps.io\n\nFollow the instructions to find the token and paste into the space provided.\n\nSo exciting! Now, you are ready to publish to shinyapps.io!\n\nCheck all the files you want uploaded to the shinyapps.io server. In our case with this demo, it should only be one file, FirstDemoApp.R.\n\n\nThat’s it! You’ve done it!! Now sit back and watch the cash and attention role in! If you want to find your app on the shinyapps.io dashboard, you can login here or below.\n\n\n\n\n\nAt this point, you know enough to open existing apps on Shiny Gallery, copy and modify their code, and publish them on shinyapps.io. In chapter 11b, we’ll be going over many of the inputs and outputs with an exercise that will help you design apps based on your needs."
  },
  {
    "objectID": "shinyapps.html#conclusion",
    "href": "shinyapps.html#conclusion",
    "title": "11  Shiny apps",
    "section": "11.6 Conclusion",
    "text": "11.6 Conclusion\nIn this chapter, we’ve covered what shiny is and how to get started. You can open existing Shiny apps, and start exploring their code, or adapting them to your own needs.\nThere is an extensive amount of tutorials and documentation on making apps with Shiny and you can find some of those in the References section below. Chapters in this course are a living document, so if you have suggestions for materials you found helpful, please send them along to us.\nThe next section of chapter 11 moves into a more detailed view of the inputs and outputs, layout options, and discusses reactivity in more depth."
  },
  {
    "objectID": "shinyapps.html#references",
    "href": "shinyapps.html#references",
    "title": "11  Shiny apps",
    "section": "11.7 References:",
    "text": "11.7 References:\nI took inspiration and guidance from many sources which I’ve tried to include here:\nThe Bookdown library for R, at bookdown.org, provides a tutorial on how to build Shiny apps.\nMastering Shiny by Hadley Wickham https://mastering-shiny.org/index.html\nW3 color resources: https://www.w3schools.com/colors/default.asp"
  },
  {
    "objectID": "working_with_strings.html#learning-objectives",
    "href": "working_with_strings.html#learning-objectives",
    "title": "4  Working with strings",
    "section": "4.1 Learning objectives",
    "text": "4.1 Learning objectives\n\nTransform strings\nCombine strings\nSplit strings\nSubset strings"
  },
  {
    "objectID": "working_with_strings.html#dealing-with-messy-or-unstructured-data",
    "href": "working_with_strings.html#dealing-with-messy-or-unstructured-data",
    "title": "4  Working with strings",
    "section": "4.2 Dealing with messy or unstructured data",
    "text": "4.2 Dealing with messy or unstructured data\nIn the last chapter, we focused on how to import data into tibbles and then reshape them so that they fit the tidy data criteria. In most cases, we had data with some structure which we transformed into a different structure. This week we look at working with strings for three reasons: cleaning messy data, filtering rows based on part of strings matches, and extracting data from text.\n\n4.2.1 Cleaning messy data\nSometimes you may be dealing with data that has the correct tidy structure, but the data itself is not clean and contains errors, unnecessary characters, or unwanted spelling or formatting variants. We need to clean that data before we conduct our analysis.\n\n\n\nfull_names (messy)\nfull_names (tidy)\n\n\n\n\nColin Conrad, PhD\nColin Conrad\n\n\nMACDONALD, Betrum\nBertrum MacDonald\n\n\nDr. Louise Spiteri\nLouise Spiteri\n\n\nMongeon, Philippe\nPhilippe Mongeon\n\n\njennifer grek-martin\nJennier Grek-Martin\n\n\n\n\n\n4.2.2 Filtering rows based on string matches\nIn the last chapter, we learned how to filter rows of a tibble based on the value contained in a cell or based on the row number. This week we will add to our toolbox some string matching functions that check if a string of characters is found within a larger string of character. One example could be retrieving a set of course codes starting with INFO or MGMT in a vector containing the course codes of all offerings of Dalhousie University.\n\n\n4.2.3 Extracting data from text\nSometimes you may have to deal with unstructured data, for example a long character string, that contain data elements that we wish to extract. Take this character string for example:\n\nI am taking several courses offered at SIM this Winter. There is INFO6270 (Introduction to Data Science) and also INFO6540 and the information policy one, which I think has the course code INFO6610.\n\nMaybe you had the brilliant idea to use a free text field in a survey to collect information about the courses that students are taking this Winter, and you now have three thousands responses that look like this one. This is unstructured data that needs to be structured before it can be analyzed and in this specific example, R can help! This kind of task can be relatovely simple, but it can get qutie complex. In this chapter, we will not do very complex data extractions from strings."
  },
  {
    "objectID": "working_with_strings.html#the-stringr-package",
    "href": "working_with_strings.html#the-stringr-package",
    "title": "4  Working with strings",
    "section": "4.3 The stringr package",
    "text": "4.3 The stringr package\nThe stringr package (https://stringr.tidyverse.org) is part of the tidyverse and contains a collection of functions that perform all kinds of operations on strings. Let’s go through some of those tasks and some code examples.\n\n4.3.1 Tansforming strings\n\n4.3.1.1 change string character case\nOne of the simple transformation that you may want to perform on a string is changing its case. This is very easily done with the str_to_lower(), str_to_upper(), str_to_sentence(), and str_to_title() functions.\n\n\n\nStatement\nOutput\n\n\n\n\nstr_to_lower(“HeLlO WoRlD!”)\nhello world!\n\n\nstr_to_upper(“HeLlO WoRlD!”)\nHELLO WORLD!\n\n\nstr_to_sentence(“HeLlO WoRlD!”)\nHello world!\n\n\nstr_to_title(“HeLlO WoRlD!”)\nHello World!\n\n\n\n\n4.3.1.1.1 Vector example\n\n# I create a vector with character strings\nvector <- c(\"I like coding with R\",\"i like coding in R\",\"R IS AMAZING!\",\"I LoVe R\")\n\n# I convert them all to lowercase.\nstr_to_lower(vector)\n\n[1] \"i like coding with r\" \"i like coding in r\"   \"r is amazing!\"       \n[4] \"i love r\"            \n\n\n\n\n4.3.1.1.2 Tibble example\n\n# I create a tibble with inconsistent strings\nt <- tibble(comments = c(\"I like coding with R\",\"i like coding in R\",\"R IS AMAZING!\",\"I LoVe R\"))\n\n# I use the mutate() and str_to_lower function to modify the messy column and make the strings consistent. \nt %>% \n  mutate(comments = str_to_lower(comments))\n\n# A tibble: 4 × 1\n  comments            \n  <chr>               \n1 i like coding with r\n2 i like coding in r  \n3 r is amazing!       \n4 i love r            \n\n\n\n\n\n4.3.1.2 Replacing parts of strings\nThe functions str_replace() and str_replace_all() modify strings by replacing a pattern with another. The difference between the two is that str_replace() will only replace the first instance of the pattern in the string, while str_replace_all() will replace all the instances.\n\n4.3.1.2.1 Vector example\n\n# I create a vector with two strings.\nnames <- c(\"dr Mike Smit\",\"dr Sandra Toze\")\n\n# I replace the first instance of the pattern \"dr\" with \"doctor\". \nnames %>% \n  str_replace(\"dr\",\"doctor\")\n\n[1] \"doctor Mike Smit\"   \"doctor Sandra Toze\"\n\n\nNow let’s see what happens if I do the same example but use str_replace_all() instead of str_replace().\n\n# I create a vector with two strings.\nnames <- c(\"dr Mike Smit\",\"dr Sandra Toze\")\n\n# I replace ALL instances of the pattern \"dr\" with \"doctor\". \nnames %>% \n  str_replace_all(\"dr\",\"doctor\")\n\n[1] \"doctor Mike Smit\"       \"doctor Sandoctora Toze\"\n\n\nThe second string got messed up because the second “dr” pattern in Sandra also got replaced with the pattern “doctor”.\n\n\n\n4.3.1.3 Removing parts of strings\nThe str_remove() and str_remove_all() are the equivalent of str_replace(\"some pattern\", \"\") and str_replace_all(\"some pattern\", \"\"). They can make our code a little cleaner by not requiring that we specify that we want to replace a given pattern with nothing.\n\n# I create a vector with names\nnames <- c(\"dr Mike Smit\",\"dr Sandra Toze\")\n\n# I remove the first instance of the pattern \"dr\" from the names.\nnames %>% \n  str_remove(\"dr\")\n\n[1] \" Mike Smit\"   \" Sandra Toze\"\n\n\n\n4.3.1.3.1 Tibble example\n\n# I create a tibble with professor names.\nt <- tibble(names = c(\"dr Mike Smit\",\"dr Sandra Toze\"))\n\n# I remove all instance of the pattern \"dr\" in the names. \nt %>% \n  mutate(names = str_remove_all(names, \"dr\"))\n\n# A tibble: 2 × 1\n  names       \n  <chr>       \n1 \" Mike Smit\"\n2 \" Sana Toze\"\n\n\nWe can see that again removing all the “dr” patterns from the strings caused a problem because the pattern is also found in the name “Sandra”.\n\n\n\n\n4.3.2 Removing extra spaces\nThe str_squish() function is a quick and easy way to remove unwanted spaces before or after a string, as well as consecutive spaces within a string.\n\nmessy_string <- \"   My cat just    stepped on the spacebar  as I was writing this      \"\n\n# Let's print the string to see what it looks like\nmessy_string\n\n[1] \"   My cat just    stepped on the spacebar  as I was writing this      \"\n\n# Let's squish it!\nstr_squish(messy_string)\n\n[1] \"My cat just stepped on the spacebar as I was writing this\"\n\n\nthe str_trim()function is similar to str_squish() but allows you to specify which types of extra spaces you wish to remove. However, it only handles trailing spaces at the beginning or end of strings, and cannot remove extra spaces extra spaces in the middle of a string.\n\nstring <- \"  hello   world    \"\n\n# remove spaces at the beginning\nstring %>% \n  str_trim(\"left\")\n\n[1] \"hello   world    \"\n\n# remove spaces at the end\n# remove spaces at the beginning\nstring %>% \n  str_trim(\"right\")\n\n[1] \"  hello   world\"\n\n# remove spaces at the beginning and at the end\nstring %>% \n  str_trim(\"both\")\n\n[1] \"hello   world\"\n\n\n\n\n4.3.3 Combine strings\nWe already learned how to use the unite() function of the tidyr package to concatenate multiple data frame columns into one. However, the unite() function works only with data frames as input, which can be limiting. The stringr package offers a str_c() function that works with vectors, so it’s good to know how to use both functions.\n\n4.3.3.0.1 Vector example\n\n# I create a vector with first names\nfirst_names = c(\"Bertrum\", \"Colin\", \"Louise\")\n\n# I create a vector with last names\nlast_names = c(\"MacDonald\", \"Conrad\", \"Spiteri\")\n\n# I combined my vectors into a new vector with full names\nfull_names <- str_c(first_names, last_names, sep = \" \")\n\n# I print the vector\nprint(full_names)\n\n[1] \"Bertrum MacDonald\" \"Colin Conrad\"      \"Louise Spiteri\"   \n\n\nAnother advantage of the str_c() over the unite() function is that it is more flexible in terms of the strings that get concatenated. You could use it to combine the content of two vectors but also add any pattern you want to any string.\n\n# I create a tibble with two columsn containing first and last names.\nmy_tibble = tibble(first_name = c(\"Bertrum\", \"Colin\", \"Louise\"),\n               last_name = c(\"MacDonald\", \"Conrad\", \"Spiteri\"))\n\n# I add a column to my tibble with full_names\nmy_tibble %>% \n  mutate(full_name = str_c(first_name, last_name, sep=\" \"))\n\n# A tibble: 3 × 3\n  first_name last_name full_name        \n  <chr>      <chr>     <chr>            \n1 Bertrum    MacDonald Bertrum MacDonald\n2 Colin      Conrad    Colin Conrad     \n3 Louise     Spiteri   Louise Spiteri   \n\n# I add a column to my tibble with full_names and include the Dr. pattern at the beginning of the name.\nmy_tibble %>% \n  mutate(full_name = str_c(\"Dr.\", first_name, last_name, sep=\" \"))\n\n# A tibble: 3 × 3\n  first_name last_name full_name            \n  <chr>      <chr>     <chr>                \n1 Bertrum    MacDonald Dr. Bertrum MacDonald\n2 Colin      Conrad    Dr. Colin Conrad     \n3 Louise     Spiteri   Dr. Louise Spiteri   \n\n\n\n\n\n4.3.4 Splitting strings\nThe str_split() function does the same thing as the separate() function that we learned about in chapter 3. They have slightly different syntax and arguments, but the main difference between the two functions is that str_split() works with vectors and returns a list, while separate() works with dara frames and returns a data frame. In other words, if you want to split a string contained in a dataframe column, you need to use separate(), and if we want to split a character vector into a list of character vectors. the n argument of str_split() allows us to specify the length of the returned vector. The basic syntax is str_split(character_vector, separator).\n\ncourses = c(\"INFO5500, INFO6540, INFO6270\",\n            \"INFO5500\",\n            \"INFO5530, INFO5520\")\n\n# str_split seperates the vectors based on a specified delimiter.\n# the outcome is a list of three vectors with 3, 1 and 2 elements.\ncourses %>% \n  str_split(\", \")\n\n[[1]]\n[1] \"INFO5500\" \"INFO6540\" \"INFO6270\"\n\n[[2]]\n[1] \"INFO5500\"\n\n[[3]]\n[1] \"INFO5530\" \"INFO5520\"\n\n\nWe can also specify the maximum number of pieces we want to split the string into.\n\n# Here I split the courses vector into a list of vectors that can have a maximum of 2 elements.\ncourses %>% \n  str_split(\", \",n=2)\n\n[[1]]\n[1] \"INFO5500\"           \"INFO6540, INFO6270\"\n\n[[2]]\n[1] \"INFO5500\"\n\n[[3]]\n[1] \"INFO5530\" \"INFO5520\"\n\n\nWe can also specify the exact number of pieces we want to split the string into with str_split_fixed(). This function does not return a vector but a matrix.\n\n# I split the courses vector into a matrix with 4 columns.\ncourses %>% \n  str_split_fixed(\", \",n=4)\n\n     [,1]       [,2]       [,3]       [,4]\n[1,] \"INFO5500\" \"INFO6540\" \"INFO6270\" \"\"  \n[2,] \"INFO5500\" \"\"         \"\"         \"\"  \n[3,] \"INFO5530\" \"INFO5520\" \"\"         \"\"  \n\n\n\n4.3.4.1 str_flatten\nThe str_flatten() function takes a character vector of length x and concatenates all the elements into a character vector of length 1 (a single string) with a specified separator between the elements. In a sense, it is the opposite of a str_split(). It’s basic syntax is str_flatten(vector, separator)\n\n4.3.4.1.1 Vector example\n\nx <- c(\"a\",\"b\",\"c\")\nstr_flatten(x,\"|\")\n\n[1] \"a|b|c\"\n\n\n\n\n4.3.4.1.2 tibble example\nUsing str_flatten() in a tibble is tricky (we need to use the group_by() function that we briefly mentioned in the previous chapter but haven’t thoroughly explored yet), but also counter-intuitive, since it likely means that we are taking a tibble in a tidy format and making it untidy.\n\n# Here is a tibble\nmy_tibble <- tibble(instructor = c(\"Mongeon, Philippe\", \"Mongeon, Philippe\", \"Mongeon, Philippe\",\"Spiteri, Louise\",\"Spiteri, Louise\"),\n            course = c(\"INFO5500\",\"INO6540\",\"INFO6270\",\"INFO6350\",\"INFO6480\"))\n\nprint(my_tibble)\n\n# A tibble: 5 × 2\n  instructor        course  \n  <chr>             <chr>   \n1 Mongeon, Philippe INFO5500\n2 Mongeon, Philippe INO6540 \n3 Mongeon, Philippe INFO6270\n4 Spiteri, Louise   INFO6350\n5 Spiteri, Louise   INFO6480\n\n\nNow I want to flatten my course column so that I have all the courses taught by the same instructor in a single row and separated with a “|”.\n\nmy_tibble %>% \n  group_by(instructor) %>% \n  mutate(course = str_flatten(course, \" | \")) %>% \n  unique()\n\n# A tibble: 2 × 2\n# Groups:   instructor [2]\n  instructor        course                       \n  <chr>             <chr>                        \n1 Mongeon, Philippe INFO5500 | INO6540 | INFO6270\n2 Spiteri, Louise   INFO6350 | INFO6480          \n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe unique() function at the end of the previous code removes the duplicates that are typically created with the str_flatten() function. You can try it yourself and see what happens when you don’t include the unique() step at the end.\n\n\n\n\n\n\n4.3.5 Subsetting strings\n\n4.3.5.1 str_sub\nSay we want to retrieve the first three characters of string. A postal code, for instance. We can do that with the str_sub() function. It’s basic syntax is str_sub(string, start, end)\n\n4.3.5.1.1 Vector example\n\npostal_code <- \"B3H 4R2\"\n\n# get the first three characters of the postal code\npostal_code %>% \n  str_sub(1,3)\n\n[1] \"B3H\"\n\n\nYou can also retrieve the last characters of the string using negative numbers. Let’s get the last three characters of the postal code.\n\npostal_code %>% \n  str_sub(-3,-1)\n\n[1] \"4R2\"\n\n\n\n\n4.3.5.1.2 Tibble example\n\n# I create my tibble \nt <- tibble(postal_code = c(\"B3H 4R2\", \"B3H 7K7\"))\n\n# I print my tibble\nt\n\n# A tibble: 2 × 1\n  postal_code\n  <chr>      \n1 B3H 4R2    \n2 B3H 7K7    \n\n# I add two new columms with the first three digits and the last 3 digits of the postal code. \nt <- t %>% \n  mutate(first_three_digits = str_sub(postal_code, 1, 3),\n         last_three_digits = str_sub(postal_code, -3, -1)) \n\n# I print my new tibble\nt\n\n# A tibble: 2 × 3\n  postal_code first_three_digits last_three_digits\n  <chr>       <chr>              <chr>            \n1 B3H 4R2     B3H                4R2              \n2 B3H 7K7     B3H                7K7              \n\n\nNoticed how I created two new columns with the same mutate()? You can mutate as many things as you want in a single mutate() function. You simply need to add a comma to separate each mutation.\n\n\n\n4.3.5.2 str_subset\nThe str_sub() function should not be confused with the str_subset() functions that returns the element of a vector that contain a string. It’s basic syntax is str_subset(character_vector, string_to_find)\n\n# I create a vector with course codes\ncourse_codes <- c(\"INFO5500\", \"BUSI6500\", \"MGMT5000\", \"INFO6270\")\n\n# I print a vector of course codes that contain the pattern \"INFO\"\nstr_subset(course_codes, \"INFO\")\n\n\n\n\n\n\n\nDanger\n\n\n\nNote that you should not try to use the str_subset() function with a tibble. It is possible, but requires the combination of multiple functions, and it’s not something that you are likely to need to do anyways.\n\n\n\n\n\n4.3.6 Locating a pattern in a string\nThe str_locate() function allows you to find the position of a pattern in a string. This can be useful, for instance, in combination with str_sub() if you want to extract the part of a string that comes before or after the pattern. Let’s explore the str_locate() function with a few examples.\n\n4.3.6.0.1 Vector examples\n\n# I create a string with an email\nemail <- \"info@somewebsite.ca\"\n\n# I locat the @ character\nemail %>% \n  str_locate(\"@\")\n\n     start end\n[1,]     5   5\n\n\nYou can see that the str_locate() returns a matrix with the beginning and the end of the “@” pattern in the email. If we want to get the part of the strings that come before the “@”, then we can do this:\n\n# I get the first part of the email\nstr_sub(email, 1,str_locate(email,\"@\")[,1]-1)\n\n[1] \"info\"\n\n\nWe did three things there:\n\nWe used 1 as the first argument of str_sub() to specify that we want to extract a subset of the email starting with the 1st character.\nWe used [,1] to obtain the first column in the matrix which is where our pattern starts (the 5th position).\nWe substracted 1 because we don’t want to print characters 1 to 5, which would be “info@” but charachters 1 to 4.\n\nSo our statement, in English, would read like this: extract the subset of the email string that starts at the first position and ends one position before where the “@” pattern is located.\nWe can get the part that comes after the pattern “@” like this:\n\nemail %>% \n  str_sub(str_locate(email,\"@\")[,2]+1,-1)\n\n[1] \"somewebsite.ca\"\n\n\nThis reads as give me the subset of the email string that starts one position after the location of the “@” pattern (str_locate(email,\"@\")[,2]+1), and ends with the last character of the string (-1). Note that the “,-1” part is optional since by default the str_sub() function will output the rest of the string when not end position is provide.\n\n\n4.3.6.0.2 Tibble example\nLet’s just repeat the same example but working with a tibble.\n\n# We create a tibble than contains some emails\nmy_tibble <- tibble(emails = c(\"info@somewebsite.ca\",\"support@datascienceisfun.com\"))\n\n# We print the tibble\nprint(my_tibble)\n\n# A tibble: 2 × 1\n  emails                      \n  <chr>                       \n1 info@somewebsite.ca         \n2 support@datascienceisfun.com\n\n# We remove the part of the emails after the @\nmy_tibble %>% \n  mutate(emails = str_sub(emails, 1, str_locate(emails,\"@\")[,1]-1))\n\n# A tibble: 2 × 1\n  emails \n  <chr>  \n1 info   \n2 support\n\n# We remove the part of the emails before the @\nmy_tibble %>% \n  mutate(emails = str_sub(emails, str_locate(emails,\"@\")[,2]+1))\n\n# A tibble: 2 × 1\n  emails              \n  <chr>               \n1 somewebsite.ca      \n2 datascienceisfun.com\n\n# Let's make this a bit more complex, and print only the part between the \"@\" and the \".\"\nmy_tibble %>% \n  mutate(emails = str_sub(emails, # strint to subset\n                          str_locate(emails,\"@\")[,2]+1, # starting position\n                          str_locate(emails,\"\\\\.\")[,1]-1)) # ending position\n\n# A tibble: 2 × 1\n  emails          \n  <chr>           \n1 somewebsite     \n2 datascienceisfun\n\n\n\n\n\n4.3.7 Testing strings\nRather than extracting parts of strings, or modifying strings, you may just want to test to see if a strings contains a specific pattern and get a logical (TRUE, FALSE) in return.\n\n4.3.7.1 str_detect\nThe str_detect() functions allows us to identify strings that contain a certain pattern. It’s syntax is str_detect(character_vector, string_to_detec).\n\n4.3.7.1.1 Vector example\n\npostal_code = c(\"B3H 1H5\",\"B3H 382\",\"H2T 1H2\",\"J8P 9R2\")\nstr_detect(postal_code, \"B3H\")\n\n[1]  TRUE  TRUE FALSE FALSE\n\n\nThis can be useful if we want to filter a tibble based on pattern matches. Here’s an example where we have a list of postal codes and would like to keep only those who are in Halifax.\n\n\n4.3.7.1.2 Tibble example\n\n# I create a tibble with postal codes\nmy_tibble <- tibble(postal_code = c(\"B3H 1H5\",\"B3H 382\",\"H2T 1H2\",\"J8P 9R2\"))\n\n# I print the rows that for which the postal code contains the pattern \"B3H\"\nmy_tibble %>% \n  filter(str_detect(postal_code,\"B3H\"))\n\n# A tibble: 2 × 1\n  postal_code\n  <chr>      \n1 B3H 1H5    \n2 B3H 382    \n\n\n\n\n\n4.3.7.2 str_starts and str_ends\nThe str_starts() and str_ends() functions do the same thing as str_detect(), but look fpr the pattern specifically at the beginning or the end of the strings.\n\n# I create a tibble with postal codes\nt <- tibble(postal_code = c(\"B3H 1H5\",\"B3H 382\",\"H2T 1H2\",\"J8P 9R2\"))\n\n# I print the postal codes that begin with \"B3H\"\nt %>% \n  filter(str_starts(postal_code, \"B3H\"))\n\n# A tibble: 2 × 1\n  postal_code\n  <chr>      \n1 B3H 1H5    \n2 B3H 382    \n\n# I print the postal codes that end with \"1H2\"\nt %>% \n  filter(str_ends(postal_code, \"1H2\"))\n\n# A tibble: 1 × 1\n  postal_code\n  <chr>      \n1 H2T 1H2    \n\n\n\n\n\n4.3.8 Regular expressions (regex)\nRegular expressions are a powerful way to search for patterns in text. A full understanding of regex is far beyond the scope of this course, but you should at least be aware of them. Below is a very superficial introduction to regular expressions. The cheat sheet for the stringr (https://github.com/rstudio/cheatsheets/blob/main/strings.pdf) package is a great place to look for guidance on using regular expressions (as well as all other functions in the stringr package, several of which that I didn’t mention in this chapter but might still be useful). It shows a list of the basic character classes, and all the operators that you can use to search for patterns in strings, so remember that it’s there to help you.\n\n4.3.8.1 Literal expressions\nIn the code examples above, we used several functions of the stringr package to search for patterns in strings (e.g., searching for the pattern “INFO” in a vector of strings.). “INFO” is a literal expression. We can also search for more than one pattern combined with the Boolean operator OR (represented by “|” in a search pattern).\n\n\n4.3.8.2 Character classes\nCharacter classes allow you to search for a range of characters or types of patterns using character classes (e.g., numbers, punctuations, symbols, letters, or a user specified set or range of characters). These classes are represented by square brackets “[ ]”.\n\n4.3.8.2.1 Example: remove unwanted characters from strings\nYou can use regular expressions to filter out of a string all the non-alphanumeric characters like this:\n\nmessy_string <- \" what-is%going*on/with!my(keyboard)\"\n\nmessy_string %>% \n  str_replace_all(\"[^[:alnum:]]\",\" \") \n\n[1] \" what is going on with my keyboard \"\n\n\nWhy does this work? Because:\n\n[:alnum:] is a character class containing all characters that are alphabetical or numerical (letters and numbers).\n[^] means everything but.\n\nSo the statement reads: replace everything but alphanumeric characters with a space.\n\n\n4.3.8.2.2 Example: find sequences of character belonging to specific classes\nWe can search for specific sequences of character classes, which can be useful to retrieve things like postal codes from a string.\n\n# We create a vector with an address\naddress <- c(\"5058 King St, Halifax, NS H2T 1J2\",\"427 Queen Avernue, Halifax, NS, B3H1H4\") \n\n# We extract the postal code from the address  \naddress %>% \n  str_extract(\"[:alpha:][:digit:][:alpha:] ?[:digit:][:alpha:][:digit:]\")\n\n[1] \"H2T 1J2\" \"B3H1H4\" \n\n\nThe pattern [:alpha:][:digit:][:alpha:] reads as: any letter, followed by any number, followed by any letter. The [:digit:][:alpha:][:digit:] patters reads as any number, followed by any letter, followed by any number.\nYou might have noticed that then there is a space and a question mark in between my two sets of three character classes. This reads as 0 or 1 space (see the quantifiers section in the stringr cheatsheet). This allows query to extract postal codes that are written with no space in between the two sets of three characters.\n\n\n4.3.8.2.3 Example: search for spelling variants\nAnother convenient way of using character classes is when you want to match a word in a text that is or isn’t capitalized. Here’s an example.\n\n# We create a tibble with 2 strings\nmy_tibble <- tibble(text = c(\"Information management is great\", \"I love information management\", \"Wayne Gretzy was the best hockey player of all times\"))\n\n# We print the tibble\nprint(my_tibble)\n\n# A tibble: 3 × 1\n  text                                                \n  <chr>                                               \n1 Information management is great                     \n2 I love information management                       \n3 Wayne Gretzy was the best hockey player of all times\n\n# We select the texts that contain \"information management\" or \"Information management\".\nmy_tibble %>% \n  filter(str_detect(text, \"[Ii]nformation management\"))\n\n# A tibble: 2 × 1\n  text                           \n  <chr>                          \n1 Information management is great\n2 I love information management  \n\n\n\n\n4.3.8.2.4 Example: combining mutliple search terms with “|” (boolean OR)\nInstead of using character classes, we could combine multiple search teams with the “|” that represents the Boolean operator OR.\n\nmy_tibble %>% \n  filter(str_detect(text, \"information management|Information management\"))\n\n# A tibble: 2 × 1\n  text                           \n  <chr>                          \n1 Information management is great\n2 I love information management  \n\n\nThis works, but even with just two variants, you can already tell that it makes longer statements to write.\n\n\n4.3.8.2.5 Example: searching for a range of character\n\n# I create a tibble containing letters from a to g\nmy_tibble <- tibble(letters = c(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\"))\n\n# I retrieve rows that contain letters from a to f\nmy_tibble %>% \n  filter(str_detect(letters,\"[a-f]\"))\n\n# A tibble: 6 × 1\n  letters\n  <chr>  \n1 a      \n2 b      \n3 c      \n4 d      \n5 e      \n6 f      \n\n\nAgain, we could have used “a|b|c|d|e|f” but this is less efficient. Here’s a similar example where we have lowercase and uppercase letters.\n\n# I create a tibble containing letters from a to g in lowercase and uppercase.\nmy_tibble <- tibble(letters = c(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\n                        \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"))\n\n# I retrieve rows that contain the letters a to d in lowercase or uppercase\nmy_tibble %>% \n  filter(str_detect(letters, \"[a-dA-D]\"))\n\n# A tibble: 8 × 1\n  letters\n  <chr>  \n1 a      \n2 b      \n3 c      \n4 d      \n5 A      \n6 B      \n7 C      \n8 D      \n\n\n\n\n\n4.3.8.3 Beware of the dot, it’s a wild card\nWhen matching character patterns, the “.” means any character.\n\nstring <- \"This is a string\" \n\n# I extract every character\nstr_extract_all(string, \".\")[[1]]\n\n [1] \"T\" \"h\" \"i\" \"s\" \" \" \"i\" \"s\" \" \" \"a\" \" \" \"s\" \"t\" \"r\" \"i\" \"n\" \"g\"\n\n# I replace every character with a space\nstring %>% \n  str_replace_all(\".\",\" \")\n\n[1] \"                \"\n\n\n\n\n\n4.3.9 Dealing with special characters in strings\nHere a some of the characters that you might come across when working with strings in R. When you want to insert these characters a string, you need to precede them with the escape character “\\”. Here is a table adapted from the stringr cheatsheet.\n\n\n\nString\nRepresents\nHow to search in a pattern\n\n\n\n\n\\.\n.\n\\\\.\n\n\n\\!\n!\n\\\\!\n\n\n\\?\n?\n\\\\?\n\n\n\\(\n(\n\\\\(\n\n\n\\)\n)\n\\\\)\n\n\n\\{\n{\n\\\\{\n\n\n\\}\n}\n\\\\}\n\n\n\\n\nnewline\n\\\\n\n\n\n\\t\ntab\n\\\\t\n\n\n\\\\\nbackslash \\\n\\\\\\\\\n\n\n\\’\napostrophe ’\n\\\\’\n\n\n\\”\nquotation mark ”\n\\\\”\n\n\n\\`\nbacktick `\n\\\\`\n\n\n\nHere are just a few example to so you can see how R deals with these special characters.\n\nstring <- \"Dear diary\\nWhat is wrong with me\\nMy code never works as I entend\"\n\n# If we just print the string, we see it exactly as written.\nprint(string)\n\n[1] \"Dear diary\\nWhat is wrong with me\\nMy code never works as I entend\"\n\n\nThe writeLines() function can be used to print the string where escaped characters are interpreted.\n\nwriteLines(string)\n\nDear diary\nWhat is wrong with me\nMy code never works as I entend\n\n\nLet’s read a text file (.txt) in R and see what happens.\n\nurl <- \"https://pmongeon.github.io/info6270/files/boring_story.txt\"\n\n# reads the file and produces a vector with one element for each line\nread_lines(url)\n\n[1] \"This is a \\\"story\\\" that I wrote just for the INFO6270 course.\"               \n[2] \"It's a bit of a boring story, but it's just an example. So please forgive me.\"\n[3] \"...and they were happy ever after.\\tThe end.\"                                 \n\n# reads the file and procudes a vector with a single element containing the entire content\nread_file(url) \n\n[1] \"This is a \\\"story\\\" that I wrote just for the INFO6270 course.\\nIt's a bit of a boring story, but it's just an example. So please forgive me.\\n...and they were happy ever after.\\tThe end.\"\n\n# Let's read the whole file and print it with writeLines()\nread_file(url) %>% \n  writeLines()\n\nThis is a \"story\" that I wrote just for the INFO6270 course.\nIt's a bit of a boring story, but it's just an example. So please forgive me.\n...and they were happy ever after.  The end.\n\n\n\n\n4.3.10 Summary\nThis chapter introduced you to the stringr package and the general principles of manipulating and matching character patterns in R. The goal was to give you enough of the basics so that you can fix small issues with strings in the data that you might encounter in this course, and in your professional or personal lives."
  },
  {
    "objectID": "shinyapps_part2.html#learning-objecives",
    "href": "shinyapps_part2.html#learning-objecives",
    "title": "12  ShinyApps part 2",
    "section": "12.1 Learning objecives",
    "text": "12.1 Learning objecives\nIn this chapter, we’ll be looking in more detail at the input and output functions using examples. This chapter introduces you to:\n\ninput functions for text, numbers, dates, choices, file uploads and actions,\noutput functions for text, tables, plots, images, and download formats,\nan introduction to themes to change the appearance of your application, and\nan explanation of reactivity and how its used.\n\nWe’ll be using some of the dataset standards included in R, such as mtcars and iris, as example datasets. Feel free to explore the datasets on your own, or even replace with your own data as you play with these inputs.\n\n\n\n\n\n\nTip\n\n\n\nYou can see all the datasets included in R by typing data() in the console.\nYou may also find the RStudio and Shiny cheatsheets helpful."
  },
  {
    "objectID": "shinyapps_part2.html#inputs-widgets",
    "href": "shinyapps_part2.html#inputs-widgets",
    "title": "12  ShinyApps part 2",
    "section": "12.2 Inputs & Widgets",
    "text": "12.2 Inputs & Widgets\nInputs are the ways users can enter, filter, or select information within your app. Widgets are a type of input that requires a different mode of input than text, such as a slider or button. There is a basic format to the inputs & widgets. First there is the input type, in this case, a textAreaInput(). In the first position is the inputID parameter, followed by the label parameter. These two will be consistent with all inputs. After the inputID and the label, arguments that may be unique to each follow. In this case, there is an argument for the number of rows. In general, all inputs, (including widgets) keep this order of inputID, label, arguments.\ntextAreaInput(\"story\", \"Tell me about yourself\", rows = 3)\nWhile we will address a few of these, you can find all of them and their code on the shiny gallery.\nThe syntax of the widget is the same as other inputs. Let’s look at the code below:\n\nThe inputID has some rules, just like any variable in R. It must be:\n\nFirst, a string consisting of letters, numbers, and/or underscores. Other characters like spaces, symbols, dashes, periods, etc., won’t work.\nSecond, it must be unique as you will call this in output functions.\n\nYou can find all of these in the input section in the shiny references documentation here. The following selection are some of the more commonly used ones to get you started. Inputs and outputs will be shown in context of the ui or server component. You can build an app as you go along. You may want to start with the basic structure first and try different inputs as your read through the chapter.\nlibrary(shiny)\n\nui <- fluidPage(\n\n)#close fluidPage\n\nserver <- function(input, output) {\n\n} #close server function\n\nshinyApp(ui, server)\n\n\n\n\n\n\nTip\n\n\n\nIf you ever want to know more about a function, you can always use the help section in RStudio or use the console to place a ? before the function, such as ?fluidPage.\n\n\n\n12.2.1 Text input\n\n12.2.1.0.1 textInput()\nThis is for small amounts of text, like asking for someone’s name, address, or what type of donut they like. You can find the documentation on this input here. To format text, for size, emphasis, color, etc, please see the Formatting text section at the end of the Outputs section.\nui <- fluidPage(\n  textInput(\"input_1\", \"What's your favorite donut?\"),\n  )#close fluidPage\n\n\n12.2.1.0.2 passwordInput()\nThis is for entering passwords. You can find more info here on its arguments.\nui <- fluidPage(\n  textInput(\"input_1\", \"What's your favorite donut?\"),\n  passwordInput(\"pword_1\", \"If a donut was your password, what would it be?\")\n)#close fluidPage\n\n\n12.2.1.0.3 textAreaInput()\nThis one is better for longer sections of text, like bio’s for websites, brief passages, comments, special instructions, etc. You can find more info here on its arguments.\nui <- fluidPage(\n  textInput(\"input_1\", \"What's your favorite donut?\"),\n  passwordInput(\"pword_1\", \"If a donut was your password, what would it be?\"),\n  textAreaInput(\"bio\", \"Please describe yourself as a donut\", rows = 3)\n  \n)#close fluidPage\nSo, let’s see these inputs as a complete application.\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"input_1\", \"What's your favorite donut?\"),\n  passwordInput(\"pword_1\", \"If a donut was your password, what would it be?\"),\n  textAreaInput(\"bio\", \"Please describe yourself as a donut\", rows = 3)\n)#close fluidPage\n\nserver <- function(input, output){\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n\n\n12.2.2 Number inputs\nHere are three inputs for numbers. You can find documentation here for the arguments.\n\n12.2.2.0.1 numericInput()\nui <- fluidPage(\n  numericInput(\"num_1\", \"Enter the quantity of donuts\", value = 0, min = 0, max = 12)\n)#close fluidPage\n\n\n12.2.2.0.2 sliderInput()\nSlider inputs can be used to select a single number or specify a range. Note the list argument passed in the second sliderInput() function named num_3. Documentation is here.\nui <- fluidPage(\n  sliderInput(\"num_2\", \"Enter the maximum number you can eat in one go\", value = 6, min = 0, max = 12),\n  sliderInput(\"num_3\", \"Enter the range of donuts you have been known to eat\", value=c(3,9), min=0, max=12 )\n)#close fluidPage\n\n\n12.2.2.0.3 dateInput() and dateRangeInput()\nFor single date entry, use the dateInput() function. For a range of dates, use the dateRangeInput(). Easy, right? There are format options for date inputs, such as format, language, and value which defines the starting date. The default starting date is today’s date on your system. You can use the help section to find out more or the documentation here for dateInput() and here for dateRangeInput().\nui <- fluidPage(\n  dateInput(\"order_1\", \"What date do you want to order donuts?\"),\n  dateRangeInput(\"delivery_1\",\"Between what dates do you want the donuts delivered?\")\n\n)#close fluidPage\n\n\n\n12.2.3 Choices from a list\n\n12.2.3.0.1 selectInput()\nThis provides a drop down list based on a list. In the following example, the list has been defined first, but this list could also be passed within the selectInput() function.\nflavors <- c(\"chocolate\", \"plain\", \"raspberry\", \"maple\", \"unicorn\", \"creme-filled\", \"sprinkles\", \"chef's choice\")\n\nui <- fluidPage(\n  selectInput(\"flavor_1\", \"What flavor of donut would you like?\", flavors, multiple=TRUE)\n\n)#close fluidPage\n\n\n12.2.3.0.2 radioButtons()\nRadio buttons provide a specified list of options that can be chosen. It is possible to change the text to other display types like images, icons, or HTML using the choiceNames and choiceValues aguments.\nflavors <- c(\"chocolate\", \"plain\", \"raspberry\", \"maple\", \"unicorn\", \"creme-filled\", \"sprinkles\", \"chef's choice\")\n\nui <- fluidPage(\n  radioButtons(\"flavor_button\", \"What is your second favorite flavor?\", flavors)\n\n)#close fluidPage\n\n\n12.2.3.0.3 checkboxInput() and checkboxGroupInput()\nAn alternative to radio buttons is check boxes which can be used for lists, surveys, or yes/no decions. For checkboxInput(), the value argument is a boolean TRUE or FALSE that determines if its automatically checked. checkboxGroupInput() also lets you select multiple choices, which the radio button does not.\nflavors <- c(\"chocolate\", \"plain\", \"raspberry\", \"maple\", \"unicorn\", \"creme-filled\", \"sprinkles\", \"chef's choice\")\n\nui <- fluidPage(\n  checkboxInput(\"choice_1\", \"Eat here\", value=TRUE),\n  checkboxInput(\"choice_2\", \"Take home\"),\n  checkboxGroupInput(\"multiple_choice\", \"What flavors would you like?\", flavors, selected = NULL)\n\n)#closed fluidPage\n\n\n\n\n\n\nTip\n\n\n\nBy now, you should be using the ?function, (such as ?checkboxGroupInput) in the console or searching for the function in the help page, (usually on the right in RStudio). Or use cheatsheets such as this one for shiny. This is a normal part of workflow and will help you add arguments to control input behaviours.\n\n\n\n\n\n12.2.4 Action buttons\nActions are usually used with the observeEvent() or eventReactive() functions that trigger a server side function. However, action buttons can alse be used for simple tasks without reactivity.\n\n\n\n\n\n\nNote\n\n\n\nClient side? Server side? What does this mean?\nThe client-server relationship is the basic framework for how the internet works. Your laptop, (tablet, desktop, or phone) are considered clients and request information from a server when you ‘go to a webpage’. This is also loosely termed front-end (client) and back-end (server). In our case, when you go to a webpage that is run by Shiny, your device (the client) requests information from the server, and the webpage loads once. If you refresh, it loads again. These computations happen on the server. Servers are faster, routinely maintained, and always on, so running computations on the server can be desirable. We’ll learn more about this in the Reactivity section.\n\n\n\n12.2.4.0.1 actionButton()\nThere are different button types already formatted for you. These include btn-primary, btn-success, btn-info, btn-warning, or btn-danger. You can modify these with sizes, such as btn-lg, btn-sm, btn-xs.\nui <- fluidPage(\n  fluidRow(\n    actionButton(\"btn_1\", \"Place your order\", class = \"btn-primary\"),\n    actionButton(\"btn_2\", \"Reset your order\", class = \"btn-warning\"),\n    actionButton(\"btn_3\", \"Preview your order\", class = \"btn-info\"),\n    actionButton(\"btn_4\", \"Pay for your order\", class = \"btn-warning\")\n    ),#close fluidRow\n    fluidRow(\n    actionButton(\"btn_5\", \"I can't eat any more donuts\", class = \"btn-block\")\n  )#close fluidRow\n\n)#close fluidPage\nYou can also pass icons from the FontAwesome library to buttons and connect to web links. Shiny currently only supports the v4 FontAwesome library, but if you want to use later versions, (its currently up to 6.3) then you can try the fontawesome R library.\nui <- fluidPage(\n  actionButton(inputId='link_1', label=\"See our location\", \n                          icon = icon(\"heart\"), \n                          onclick =\"window.open(\"https://goo.gl/maps/PrUi3qKEc3WFg9Hz7\", '_blank')\")\n  )\n)#close fluidPage\nThere are many more inputs available on the Shiny reference documentation, these most common ones will get you started making apps. OK! Enough with the donuts! Next, let’s go over types of outputs and how these work with inputs using a standard R dataset."
  },
  {
    "objectID": "shinyapps_part2.html#outputs",
    "href": "shinyapps_part2.html#outputs",
    "title": "12  ShinyApps part 2",
    "section": "12.3 Outputs",
    "text": "12.3 Outputs\nOutputs are paired functions with one assigned in the ui to define spaces where outputs will be seen and the other in the server function to render the result. They include a unique ID in the first position of its arguments.\nOutput ID’s are called from the server side preceded by output$outputID in which outputID is the ID (like a variable name) you’ve assigned it. You’ll see these are always calling a render* function, such as renderText(). As an example:\n\nSome important new fuctions are called. In the server() function, you see renderText(). This calls the values you assigned in input_1 and places it where you assigned it in output_1. In addition to text, you can also render tables, data tables, plots, images, and text. *Output() and render*() functions work together, with *Output() in the ui to show where output will be displayed, and render*() in the server to produce the desired information.\n\n12.3.1 Text output\n\n12.3.1.0.1 textOutput() & renderText()\nThis outputs regular text. You can see the placeholder textOutput() in the ui, and the renderText() function passed in the server. Here, we use the input of input_1 as the output for text.\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"input_1\", \"What's your favorite donut?\"),\n  h4(\"Your favorite donut is: \"),\n  textOutput(\"text\")\n  \n)#close fluidPage\n\nserver <- function(input, output) {\n  output$text <- renderText({input$input_1})\n  \n}#close server\n\nshinyApp(ui, server)\n\n\n12.3.1.0.2 verbatimTextOutput() & renderPrint()\nThis creates a console like output in the application. Lets add the dataset summary. renderPrint() prints the results of expressions, where renderText() prints text together in a string.\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"code\")\n  \n)#close fluidPage\n\nserver <- function(input, output) {\n  output$text <- renderText({\n    \"Hello. The following is a summary of a standard R dataset, mtcars\"\n  })\n  output$code <- renderPrint({\n    summary(mtcars)\n  })\n}#close server\n\n\n\n12.3.2 Tables\nOh, tables! Tables are powerful. There are two types of tables, static tables of data, and dynamic tables that are interactive.\n\n12.3.2.0.1 tableOutput() & renderTable()\nStatic tables are great for summaries or concise results. They’re good at preserving data just the way you made it.\nui <- fluidPage(\n  tableOutput(\"static\")\n)#close fluidPage\n\nserver <- function(input, output) {\n  output$static <- renderTable(head(mtcars))\n}#close server\n\n\n12.3.2.0.2 dataTableOutput() & renderDataTable()\nDataTables are much more dynamic and can be customized in numerous ways.\nui <- fluidPage(\n  dataTableOutput(\"dynamic\")\n\n)#close fluidPage\n\nserver <- function(input, output) {\n  output$dynamic <- renderDataTable(mtcars, options=list(pageLength = 6)\n  )#cloe renderDataTable\n}#close server\nDataTables are more appropriate for larger dataframes where someone may need to explore, filter, and sort data. You can find more information on modifying DataTables here.\n\n\n\n\n\n\nImportant\n\n\n\nDataTables refers to both functions in Shiny and from the DT library. Unless the library(DT) is called, references to dataTables are for the version in the Shiny library. While dataTables in the Shiny library provides only server-side tables, the DT package can provide both server-side and client-side tables. This may be an important consideration if you are trying to reduce how many working hours your application runs on shinyapps.io, for example.\n\n\n\n\n\n12.3.3 DataTables\nIn this section, we are going to explore importing data and displaying it in a DataTable using the DT library. This is different than the data.table function included in the Shiny library. The DT library makes a lovely table that can be searched, filtered, and sorted which is great for data exploration. You can find more info here and here for the DT documentation.\nlibrary(shiny)\nlibrary(DT)\n\nui <- fluidPage(\n  h2(\"Some data about flowers\"),\n  DT::dataTableOutput(\"table_1\")\n\n)#close fluidPage\n\nserver <- function(input, output) {\n  output$table_1 = DT::renderDataTable({\n  iris\n  })#close output\n\n}#close server\n\nshinyApp(ui, server)\n\n\n\n\n\n\nImportant\n\n\n\nYou can in the code above that the DT library has been called. Its also good practice to call directly from the library for functions that are present in more than one library. In this case, renderDataTable() exists in both Shiny and DT. To make it more human readable and prevent conflicts, its advised to call the function directly from the library as in the following:\nDT::renderDataTable()\n\n\n\n\n12.3.4 Computation output\nBut what if we wanted to perform some operations on the data, such as to use the summarizing functions you did in earlier chapters on the mtcars dataset? In the code below, we first import some data from a remote location, then create a DataTable for exploration. Then we summarize the data.\nlibrary(shiny)\nlibrary(DT)\nlibrary(tidyverse)\n\n\npath <- \"https://raw.githubusercontent.com/fivethirtyeight/data/master/comic-characters/marvel-wikia-data.csv\"\n\n# This will read the first sheet of the Excel file\ncomics_data <- read_csv(path)\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      h2(\"How to use DataTables from the DT library\"),\n      br(),\n      p(\"To the right is a dataset displayed as a DataTable\"), \n      p(\"This dataset is from the fivethirtyeight GitHub repository.\")\n    ),#close sidebarPanel\n    mainPanel(\n  h2(\"the dataset\"),\n  br(),\n  \n  DT::dataTableOutput(\"table_1\"), \n  \n  \n    )#close mainPanel\n  )#close sidebarLayout\n)#close fluidPage\n\nserver <- function(input, output) {\n  data_to_display <- comics_data\n\n  output$table_1 <- renderDataTable({\n   (data_to_display)\n    })\n  \n}#close server\n\nshinyApp(ui, server)\nFirst, we can drop urlslug, and page_id. We also want to correct the column names.\nlibrary(shiny)\nlibrary(DT)\nlibrary(tidyverse)\n\n\npath <- \"https://raw.githubusercontent.com/fivethirtyeight/data/master/comic-characters/marvel-wikia-data.csv\"\n\n# This will read the first sheet of the Excel file\ncomics_data <- read_csv(path)\n\ncomics_data <- select(comics_data, \"name\", \"ID\", \"ALIGN\", \"EYE\", \n                      \"HAIR\", \"SEX\", \"GSM\", \"ALIVE\", \"APPEARANCES\",\n                      \"FIRST APPEARANCE\", \"Year\" ) %>% \n                rename(Name = name,\n                       Alignment=ALIGN,\n                       Eye = EYE, \n                       Hair = HAIR,\n                       Gender = SEX, \n                       Gender_or_sexual_identity = GSM,\n                       Status = ALIVE, \n                       Appearances = APPEARANCES,\n                       First_appearance = 'FIRST APPEARANCE')\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      h2(\"How to use DataTables from the DT library\"),\n      br(),\n      p(\"To the right is a dataset displayed as a DataTable\"), \n      p(\"This dataset is from the fivethirtyeight GitHub repository.\")\n    ),#close sidebarPanel\n    mainPanel(\n      h2(\"the dataset\"),\n      br(),\n      DT::dataTableOutput(\"table_1\")#close dataTableOutput\n  \n    )#close mainPanel\n  )#close sidebarLayout\n)#close fluidPage\n\nserver <- function(input, output) {\n  data_to_display <- comics_data\n\n  output$table_1 <- renderDataTable(\n   data_to_display,\n    options = list(\n      scrollX = TRUE, \n      scrollY = TRUE,\n      autoWidth = TRUE,\n      rownames = FALSE)\n    ) #close renderDataTable\n}#close server\n\nshinyApp(ui, server)\nYou can see from this example, there are new options added to the renderDataTable() function. We also modified our data before the ui. You can find an excellent explanation of options as well as beautiful integration with the formattable library from this blog.\n\n\n\n\n\n\n\n12.3.5 Plots\nPlots are graphs and charts from packages like ggplot2, plotly, r2d3, and many others. Mastering Shiny has an excellent chapter dedicated to ggplot2 for more info on making ggplot2 interactive. For now, we’re going to stick with some simple ones to explain the basic plot output functions.\n\n12.3.5.0.1 plotOutput() & renderPlot()\nThese two work together to generate an R graphic, usually based on ggplot2 or similar graphic library.\nlibrary(shiny)\nlibrary(gglplot2)\n\nui <- fluidPage(\n  plotOutput(\"plot\", width = \"400px\")\n)#close fluidPage\nserver <- function(input, output) {\n  output$plot <- renderPlot(plot(1:10), res = 96)\n}#close server\n\nshinyApp(ui, server)\n\n\n\nA rather boring plot.\n\n\nLet’s look at something more interesting. ggplot2 supports interactive mouse inputs, such as click, dblclick, hover, and brush (rectangular select). This time we’re looking at the iris dataset.\n\nlibrary(shiny)\nlibrary(ggplot2)\n\nui <- fluidPage(\n  plotOutput(\"plot\", click = \"plot_click\"),\n  tableOutput(\"data\")\n)\nserver <- function(input, output) {\n  output$plot <- renderPlot({\n    ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) + \n      geom_point()})\n  \n  output$data <- renderTable({\n    nearPoints(iris, input$plot_click)\n  })\n}\nshinyApp(ui, server) \nBelow is just a placeholder image. Try running the code above yourself to see how the mouse click function works.\n\nMore plot types can be found on the R Graph Library with helpful example code to get you started. This library focuses on ggplot 2 and tidyverse, so you have already learned what you need to make and modify these!\n\n\n\n\n\n\n\n\n12.3.6 Images\nYou can place images or logos in your app! Of course, you also use fluidRow() and column arguments to organize your space with text and images. In this case, we are pointing to an image located at a website.\nlibrary(\"shiny\")\nui <- fluidPage(\n  mainPanel(\n    img(src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Glazed-Donut.jpg/800px-Glazed-Donut.jpg\", align = \"center\")\n  )\n)#close fluidPage\n\nserver <- function(input, output) {\n  \n}#close server\nshinyApp(ui, server)\nYou can also source your image from a directory. Your files should be saved in a folder called ‘www’ inside your working, (or root), directory.\n  shinyApp/\n     app.R\n     www/\n        glazedDonut.jpg\n        sprinkleDonut.jpg\n        cakeDonut.jpg\nA simple way to call a locally saved image, such as a logo or banner image, might be this:\nlibrary(shiny)\n\nui <- fluidPage(\n  \n    img(src=\"glazedDonut.jpg\", align = \"right\")\n\n)\n\nserver <- function(input, output) {}\n\nshinyApp(ui, server)\nHowever, if we wanted to call those locally saved images from a choice list, our code would need to look like this:\nlibrary(shiny)\n\ndonuts <- tibble::tribble(\n  ~type, ~ id, ~donut, \n  \"glazed\", \"glazedDonut\",\"GlazedDonut\",\n  \"sprinkles\", \"sprinkleDonut\", \"SprinkleDonut\",\n  \"cake\", \"cakeDonut\", \"CakeDonut\"\n)\n\nui <- fluidPage(\n  selectInput(\"id\", \"Pick a donut\", choices = setNames(donuts$id, donuts$type)),\n  imageOutput(\"photo\")\n)\nserver <- function(input, output, session) {\n  output$photo <- renderImage({\n    list(\n      src = file.path(\"www\", paste0(input$id, \".jpg\")),\n      contentType = \"image/jpeg\",\n      width = 800,\n      height = 650\n        )#close list\n    }, deleteFile = FALSE)\n}#close function\n  \nshinyApp(ui, server)\n\n\n\n\n\n\nTip\n\n\n\nPlacing many logos across a page can be very tedious and difficult to control. For example, inculding all the logos of universities involved in a research project. It may be easier to combine them all in one image file using an image editor, such as Photoshop or GiMP. Then place that one image on your page.\n\n\n\n\n\n12.3.7 File uploads\n\n12.3.7.0.1 fileInput()\nFile uploads and downloads are more complicated types of inputs and outputs. There is a special chapter dedicated to them on the Mastering Shiny webbook here. Loading data, usually in the form of a csv, is a very common need. The following code will upload a csv based on which dataset you’ve chosen from an input menu. However, this code also makes the upload available to the server function and reads it into a table.\nlibrary(shiny)\n\nui <- fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        fileInput(\"file1\", \"Choose a CSV  format File\", accept = \".csv\"),\n        checkboxInput(\"header\", \"Header\", TRUE)\n      ),\n      mainPanel(\n        tableOutput(\"contents\")\n      ) #close mainPanel\n    )#close sidebarLayout\n  )#close fluidPage\n  \nserver <- function(input, output) {\n    output$contents <- renderTable({\n      file <- input$file1\n      ext <- tools::file_ext(file$datapath)\n      \n      req(file)\n      validate(need(ext == \"csv\", \"Please upload a csv format file\"))\n      \n      read.csv(file$datapath, header = input$header)\n    })#close renderTable\n  }#close function\n  \nshinyApp(ui, server)\n\n\n\n12.3.8 Downloads\nThe download button is a special case and it’s a super useful output for people to download a dataset or whatever, such as a manipulated data from a DataTable. The downloadHandler() function is critical to this working. In this case the downloadHandler() is sending the file named data to the write.csv() function.\nui <- fluidPage(\n  downloadButton(\"downloadData\", \"Download\")\n)\n\nserver <- function(input, output) {\n  # Our dataset\n  data <- mtcars\n\n  output$downloadData <- downloadHandler(\n    filename = function() {\n      paste(\"data-\", Sys.Date(), \".csv\", sep=\",\")\n    },\n    content = function(file) {\n      write.csv(data, file)\n    }#close function\n  )#close downloadHandler\n}#close server function\n\nshinyApp(ui, server)\nWith other libraries you can also write Excel files, such as with writexl. This version writes to an Excel file.\nlibrary(shiny)\nlibrary(writexl)\n\n\nui <- fluidPage(\n    downloadButton(\"downloadData\", \"Download\")\n  )\n  \nserver <- function(input, output) {\n    # Our dataset\n    data <- mtcars\n    \n    output$downloadData <- downloadHandler(\n      filename = function() {\n        #paste(\"data-\", Sys.Date(), \".csv\", sep=\"\")\n        paste(\"data-\", Sys.Date(), \".xlsx\")\n      },\n      content = function(file) {\n        #write.csv(data, file)\n        writexl::write_xlsx(data, file)\n      } #close function\n    ) #close downloadHandler\n  }#close server function\n  \nshinyApp(ui, server)\nNext, let’s play with themes."
  },
  {
    "objectID": "shinyapps_part2.html#themes",
    "href": "shinyapps_part2.html#themes",
    "title": "12  ShinyApps part 2",
    "section": "12.4 Themes",
    "text": "12.4 Themes\nThemes control the styling of the application, unifying colors and fonts, for example. Themes are assigned in the ui(). You can find the shinythemes library here.\nlibrary(shinythemes)\n\nui = fluidPage(theme = shinytheme(\"cerulean\")\n  )#close fluidPage\n\nserver = function(input,output) {}\n\nshinyApp(ui, server)\nOr use the theme picker option until you decide on one!\nlibrary(shinythemes)\n\nui = fluidPage(\n    shinythemes::themeSelector()\n    )#close fluidPage\n    \nserver = function(input, output) {}\n\nshinyApp(ui, server)\n  \nIt is possible to create your own themes, use themes other than Bootstrap, or modify Bootstrap themes to your own aesthetic needs. Mastering Shiny has a brief chapter on themes here, and you can also find more information here on Bootswatch themes. Here is a link for the hex codes or names you’ll need for colors.\nYou can even start making your own theme by specifying items to be used throughout your app in the ui. Colors are hex or by HTML names. Collections of web safe fonts can be found here. Note how the bslib library is called and the theme is identified in the first part of the page layout. You can find the documentation on bslib here. In this case, the open-source fonts came from Google Fonts.\nlibrary(shiny)\nlibrary(bslib)\n\nui <- fluidPage(\n  theme = bs_theme( \n    bg = \"#175d8d\", \n    fg = \"#d5fbfc\", \n    primary = \" #e3fffc\", \n    base_font = font_google(\"Atkinson Hyperlegible\"),\n    code_font = font_google(\"Roboto Mono\")\n  ),\n  sidebarLayout(\n    sidebarPanel(\n      fileInput(\"file1\", \"Choose a CSV  format File\", accept = \".csv\"),\n      checkboxInput(\"header\", \"Header\", TRUE)\n    ),\n    mainPanel(\n      tableOutput(\"contents\")\n    ) #close mainPanel\n  )#close sidebarLayout\n)#close fluidPage\n\nserver <- function(input, output) {\n  output$contents <- renderTable({\n    file <- input$file1\n    ext <- tools::file_ext(file$datapath)\n    \n    req(file)\n    validate(need(ext == \"csv\", \"Please upload a csv format file\"))\n    \n    read.csv(file$datapath, header = input$header)\n  })#close renderTable\n}#close function\n\nshinyApp(ui, server)\nThere is also the shiny.semantic library for a different look. You can find the link here."
  },
  {
    "objectID": "shinyapps_part2.html#formatting-text",
    "href": "shinyapps_part2.html#formatting-text",
    "title": "12  ShinyApps part 2",
    "section": "12.5 Formatting text",
    "text": "12.5 Formatting text\n\n12.5.0.1 HTML functions\nYou can apply HTML equivalent functions in shiny to format your text by creating distinct paragraphs, emphasize text, or change the font or color. The table below shows the shiny function, such as p(), and its HTML equivalent and what is modified.\nTable source: https://shiny.rstudio.com/tutorial/written-tutorial/lesson2/\n\n\n\n\n\n\n\n\nshiny function\nHTML5 equivalent\ncreates\n\n\n\n\np\n<p>\nA paragraph of text\n\n\nh1\n<h1>\nA first level header\n\n\nh2\n<h2>\nA second level header\n\n\nh3\n<h3>\nA third level header\n\n\nh4\n<h4>\nA fourth level header\n\n\nh5\n<h5>\nA fifth level header\n\n\nh6\n<h6>\nA sixth level header\n\n\na\n<a>\nA hyper link\n\n\nbr\n<br>\nA line break (e.g. a blank line)\n\n\ndiv\n<div>\nA division of text with a uniform style\n\n\nspan\n<span>\nAn in-line division of text with a uniform style\n\n\npre\n<pre>\nText ‘as is’ in a fixed width font\n\n\ncode\n<code>\nA formatted block of code\n\n\nimg\n<img>\nAn image\n\n\nstrong\n<strong>\nBold text\n\n\nem\n<em>\nItalicized text\n\n\nHTML\n \nDirectly passes a character string as HTML code\n\n\n\nBelow is an example with many types of the HTML modifiers.\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"My Shiny App\"),\n  sidebarLayout(\n    sidebarPanel(),\n    mainPanel(\n      h1(\" h1() creates a level 1 header.\"),\n      h2(\" h2() creates a level 2 header, and so on...\"),\n      p(\"Use p() to create a new paragraph. \"),\n      p(\"You can apply style to a paragraph using style\", style = \"font-family: 'times'; font-si16pt\"),\n      strong(\"Using strong() bolds text.\"),\n      em(\"Italics can be applied with em(). \"),\n      br(),\n      p(\"Use br() to apply a line break.\"),\n      br(),\n      code(\"You can create a code box with code().\"),\n      div(\"div creates a container that can apply styles within it using 'style = color:magenta'\", style = \"color:blue\"),\n      br(),\n      p(\"span is similar to div but can affect smaller sections\",\n        span(\"such as words or phrases\", style = \"color:purple\"),\n        \"within a paragraph or body of text.\"),\n      h3(p(\"You can also combine \", \n           em(span(\"HTML\", style=\"color:magenta\")), \n           \"functions.\"))\n    )#close mainPanel\n  )#close sidebarLayout\n)#close fluidPage\nserver <- function(input, output) {\n  \n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "shinyapps_part2.html#section",
    "href": "shinyapps_part2.html#section",
    "title": "12  ShinyApps part 2",
    "section": "12.6 ",
    "text": "12.6"
  },
  {
    "objectID": "shinyapps_part2.html#reactive-pages",
    "href": "shinyapps_part2.html#reactive-pages",
    "title": "12  ShinyApps part 2",
    "section": "12.7 Reactive pages",
    "text": "12.7 Reactive pages\nIn this section, we will look at how to make your app respond to inputs and do stuff!\n\n\n\n\n\n\nImportant\n\n\n\nThis section is difficult to understand. Take your time with it, and its ok if it doesn’t make sense right away. We’ll be working with this more in class.\n\n\n\n12.7.1 Basics of reactivity\nReactivity refers to the ability of an app to recalculate or perform some action when an input is changed. In a non-reactive Shiny app, all calculations are run when the session begins. However, if you want a user to change an input and display a new calculated result, then reactivity in Shiny apps allow only that part of the app to be computed and re-displayed, not the entire app. This is important for making things fast and able to display immediate changes. So, in a sense, reactivity is something that happens in the background, or more accurately, the back-end. But, knowing about it will help you use the following functions successfully.\n\n12.7.1.1 Two different types of programming: imperative and declarative\nImperative programming is like the analysis functions you’ve been running so far in this class. You write a series of commands and R executes them. You see errors if something doesn’t match. The UI layout is imperative. You write code that says where something will be, like a radio button, sidebar text, or text output in the main panel.\nDeclarative code provides options for the program if conditions are right. So, it will execute the code if conditions are met. This is what we see on the server side function. It is a series of codes that will run if something happens in the UI.\nIn the context of reactive expressions, all code is run when you start a session and results are stored in the cache. This means that if you move a slider and a new value can be retrieved from that cache, your app will show the result. However, if you move a slider and a new calculated value needs to be shown, this value will not be in your cache. You need some part of the app to calculate and store a new value to be shown. This is where reactivity steps in. Only the part of the code that needs to run, is executed - not the entire app. These declarative bits of code are wrapped in reactive function.\n\n\n12.7.1.2 Code execution order\nUnlike imperative, declarative coding such as in the server, run only when needed. So order is not as important in the server function. However, this can make code very difficult to read for humans as we tend to assume top to bottom. In practice, its best to keep your code human readable. For example, following the order of the ui can be helpful in navigating through the server code.\nData can be very large. To prevent this from slowing down the application, every time a new input is sent to the server function, do as much of your data cleaning and manipulation outside of the ShinyApp as possible. Of course, there are just some situations where this is not possible. But as a general rule, keep it minimal inside the ShinyApp. However, you can run code before the ui and server functions if data needs to be cleaned.\n#insert example code\ntake mtcars and apply some calculation based on existing data, maybe $ to drive 100 miles or km in today.\nIn the following section, let’s look at two reactive functions commonly found. More information on reactive functions can be found here in the Shiny documentation.\n\n\n12.7.1.3 observeEvent()\nobserveEvent() has two arguments: eventExpr and handlerExpr. The first input is the input or expression to take a dependency upon, the second is the code that will be executed.\nobserveEvent() functions provide the set-up for the eventReactive() by observing the data to check for updates. When updates are noticed, the eventReactive() pulls the new updated data and the HTML updates. Note that the following code changes in the HTML to the webpage with the reactive and also prints something in the console.\n\n\n12.7.1.4 eventReactive()\nWhen you select the actionButton(), the just the part of the code that needs to run updates what you see. This is great for click events like action buttons, where a user may expect something to occur. Details of the options and examples of eventReactive() and observeEvent() can be found here in the documentation.\nBelow, we’ve used the example from the documentation to illlustrate basic reactivity. When the app first runs, nothing is displayed as there was no information in the cache for the button ID. Once the button is pressed, the x value is attached to it and the first x rows of data are shown. It does nothing until the cache is updated again when both the x value and the button values have changed.\n\n\n\n\n\n\n\nImportant\n\n\n\nReactivity in Shiny is regretably complex. However the two functions above cover the most common ones you’ll see. The free, online book, Mastering Shiny, has 4 chapters dedicated to reactivity in Shiny. For now, when you see observeEvent() and eventReactive() functions in code you are getting from other sources, you should recognize these as reactive parts of the app that will update when some input has been changed.\n\n\n\n\n12.7.1.5 What is session?\nSession is an optional argument passed to the server function that enables inputs or outputs related to the current instance of the app to be used. You may see some examples with this. If you see it in a code example, its likely there to pull an input or output that is unique to this instance and do something with it. You can read more in its documentation here.\n\nThe session state is used when we need to retrieve some data that has been stored as a result of calculations or inputs from a user’s session. It could be user data, or it could be a file they uploaded that your Shiny app then performed an operation on."
  },
  {
    "objectID": "shinyapps_part2.html#summary",
    "href": "shinyapps_part2.html#summary",
    "title": "12  ShinyApps part 2",
    "section": "12.8 Summary",
    "text": "12.8 Summary\nReactivity is different due to the nature of declarative programming. It makes code less complex and providies conditions that could be met, rather than a linear progression of code to be executed. We use reactivity so that people can change inputs and receive different outputs or make external actions happen.\nRecognizing reactive functions of eventReactive() and observeEvent() and why its used on the back-end of a Shiny app will help in designing and debugging your code.\n\nYou can put code before the Shiny ui code to reduce calculation time.\nobserveEvent() sets up the reactivity by signaling which inputs the app should look for change.\neventReactive() is used to render or provide some action based on the updated input values."
  },
  {
    "objectID": "shinyapps_part2.html#wrap-up",
    "href": "shinyapps_part2.html#wrap-up",
    "title": "12  ShinyApps part 2",
    "section": "12.9 Wrap up",
    "text": "12.9 Wrap up\nThat was a massive chapter, but this is intended to be used as a reference for you for your future explorations in Shiny. By the end of this you have learned more about many of the Shiny inputs and output functions, how they work together, and an introduction to themes and formatting text. We also introduced reactivity in Shiny which is an important concept as you move forward into more complex interactions. You now have enough information to create and publish web-based applications. Combined with what you have covered in the previous chapters, you are now well prepared to create, modify, calculate, and publish your own research!"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Blei, David M., and Padhraic Smyth. 2017. “Science and Data\nScience.” Proceedings of the National Academy of\nSciences 114 (33): 8689–92. https://doi.org/10.1073/pnas.1702076114.\n\n\nHealy, Kieran. 2018. Data Visualization: A Practical\nIntroduction. Princeton, NJ: Princeton University Press.\n\n\nRhys, Hefin. 2020. Machine Learning with r, the Tidyverse, and\nMlr. Shelter Island, NY: Manning publications.\n\n\nWickham, Hadley. 2014. “Tidy Data.” Journal of\nStatistical Software 59 (September): 1–23. https://doi.org/10.18637/jss.v059.i10.\n\n\n———. 2016. Ggplot2. Springer International Publishing. https://doi.org/10.1007/978-3-319-24277-4.\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science:\nImport, Tidy, Transform, Visualize, and Model Data. First edition.\nSebastopol, CA: O’Reilly.\n\n\nWilke, C. 2019. Fundamentals of Data Visualization: A Primer on\nMaking Informative and Compelling Figures. First edition.\nSebastopol, CA: O’Reilly Media."
  }
]